name: build-release

on:
  push:
    branches: [ main ]
    tags: [ "v*" ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      build_macos_x64:
        description: 'Build optional macOS x64 artifact (requires macos-13 runner support)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

permissions:
  contents: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Linux dependencies (validate)
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libglib2.0-dev \
            libgtk-3-dev \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf

      - name: Install Rust toolchain (fmt/clippy)
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: npm
          cache-dependency-path: ui/package-lock.json

      - name: Install frontend dependencies
        working-directory: ui
        run: npm ci

      - name: Rust fmt check
        run: cargo fmt --manifest-path src-tauri/Cargo.toml --all -- --check

      - name: UI lint
        run: npm --prefix ui run lint

      - name: Preflight (validate)
        shell: bash
        run: |
          bash scripts/preflight.sh build-ui

      - name: Rust clippy check
        run: cargo clippy --manifest-path src-tauri/Cargo.toml --all-targets

  build:
    needs: [ validate ]
    env:
      APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
      APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
      APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            artifact_suffix: linux-x64
            allow_failure: false
          - os: windows-latest
            artifact_suffix: windows-x64
            allow_failure: false
          - os: macos-14
            artifact_suffix: macos-arm64
            allow_failure: false
    runs-on: ${{ matrix.os }}
    continue-on-error: ${{ matrix.allow_failure }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: npm
          cache-dependency-path: ui/package-lock.json

      - name: Cache cargo
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            . -> target
            src-tauri -> src-tauri/target

      - name: Install frontend dependencies
        working-directory: ui
        run: npm ci

      - name: Preflight (build)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          bash scripts/preflight.sh build-ui

      - name: Preflight (build Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          ./scripts/preflight.ps1 -Mode build-ui

      - name: Package browser extensions
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p browser-extension/dist browser-extension/dist/firefox
          zip -r browser-extension/dist/flamingo-browser-extension-chromium.zip browser-extension \
            -x "browser-extension/dist/*" "browser-extension/manifest.firefox.json"

          cp browser-extension/background.js browser-extension/i18n.js browser-extension/options.js browser-extension/options.html browser-extension/popup.html browser-extension/popup.js browser-extension/dist/firefox/
          cp browser-extension/manifest.firefox.json browser-extension/dist/firefox/manifest.json
          (cd browser-extension/dist/firefox && zip -r ../flamingo-browser-extension-firefox.zip .)

      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf \
            aria2

      - name: Install macOS dependencies
        if: runner.os == 'macOS'
        run: |
          brew update
          brew install aria2

      - name: Install Windows dependencies
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          choco install aria2 -y --no-progress

      - name: Prepare macOS signing keychain
        if: runner.os == 'macOS' && env.APPLE_CERTIFICATE != '' && env.APPLE_CERTIFICATE_PASSWORD != '' && env.APPLE_SIGNING_IDENTITY != ''
        shell: bash
        run: |
          set -euo pipefail
          CERT_PATH="$RUNNER_TEMP/build_certificate.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"

          # Support both base64-encoded and plain-text secret payloads.
          if printf '%s' "$APPLE_CERTIFICATE" | base64 --decode > "$CERT_PATH" 2>/dev/null; then
            echo "APPLE_CERTIFICATE decoded from base64"
          else
            printf '%s' "$APPLE_CERTIFICATE" > "$CERT_PATH"
            echo "APPLE_CERTIFICATE treated as raw payload"
          fi
          if [ ! -s "$CERT_PATH" ]; then
            echo "Certificate payload is empty after decode/import preparation."
            exit 1
          fi
          echo "Prepared certificate payload size: $(wc -c < "$CERT_PATH") bytes"
          file "$CERT_PATH" || true
          openssl pkcs12 -in "$CERT_PATH" -nokeys -passin "pass:$APPLE_CERTIFICATE_PASSWORD" -info >/dev/null 2>&1 \
            && echo "PKCS12 precheck: ok" \
            || (echo "PKCS12 precheck failed (password/format mismatch)"; exit 1)

          security create-keychain -p "" "$KEYCHAIN_PATH"
          security set-keychain-settings "$KEYCHAIN_PATH"
          security unlock-keychain -p "" "$KEYCHAIN_PATH"
          security import "$CERT_PATH" -k "$KEYCHAIN_PATH" -P "$APPLE_CERTIFICATE_PASSWORD" -f pkcs12 -T /usr/bin/codesign -T /usr/bin/security
          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple: -k "" "$KEYCHAIN_PATH"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

      - name: Print macOS signing mode
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${APPLE_CERTIFICATE}" ] && [ -n "${APPLE_CERTIFICATE_PASSWORD}" ] && [ -n "${APPLE_SIGNING_IDENTITY}" ]; then
            if [ -n "${APPLE_ID}" ] && [ -n "${APPLE_PASSWORD}" ] && [ -n "${APPLE_TEAM_ID}" ]; then
              echo "macOS mode: signed + notarized (all Apple secrets present)"
            else
              echo "macOS mode: signed only (notarization secrets missing)"
            fi
          else
            echo "macOS mode: unsigned fallback (signing secrets missing)"
          fi

      - name: Stage aria2 binary (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          bash scripts/ci/prepare_aria2_unix.sh

      - name: Stage aria2 binary (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          ./scripts/ci/prepare_aria2_windows.ps1

      - name: Verify staged aria2 (Linux/macOS)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          case "${RUNNER_OS}" in
            Linux) platform="linux" ;;
            macOS) platform="macos" ;;
            *) echo "unsupported runner os: ${RUNNER_OS}" ; exit 1 ;;
          esac
          test -x "aria2/bin/aria2c"
          test -x "aria2/bin/${platform}/aria2c"
          test -x "src-tauri/resources/aria2/bin/aria2c"
          test -x "src-tauri/resources/aria2/bin/${platform}/aria2c"
          aria2/bin/aria2c --version | head -n 1
          src-tauri/resources/aria2/bin/aria2c --version | head -n 1

      - name: Verify staged aria2 (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $paths = @(
            "aria2/bin/aria2c.exe",
            "aria2/bin/windows/aria2c.exe",
            "src-tauri/resources/aria2/bin/aria2c.exe",
            "src-tauri/resources/aria2/bin/windows/aria2c.exe"
          )
          foreach ($p in $paths) {
            if (!(Test-Path $p)) { throw "missing staged aria2 binary: $p" }
          }
          & "aria2/bin/aria2c.exe" --version | Select-Object -First 1
          & "src-tauri/resources/aria2/bin/aria2c.exe" --version | Select-Object -First 1

      - name: Install tauri-cli
        if: runner.os != 'Windows'
        uses: actions/cache@v4
        with:
          path: ~/.cargo/bin/cargo-tauri
          key: ${{ runner.os }}-cargo-tauri-v2

      - name: Cache tauri-cli (Windows)
        if: runner.os == 'Windows'
        uses: actions/cache@v4
        with:
          path: ~\.cargo\bin\cargo-tauri.exe
          key: ${{ runner.os }}-cargo-tauri-v2

      - name: Install tauri-cli (if missing)
        shell: bash
        run: |
          set -euo pipefail
          if command -v cargo-tauri >/dev/null 2>&1; then
            cargo-tauri --version
          else
            cargo install tauri-cli --version "^2.0" --locked
            cargo-tauri --version
          fi

      - name: Build app bundle (non-macOS)
        if: runner.os != 'macOS'
        working-directory: src-tauri
        run: cargo tauri build

      - name: Build app bundle (macOS signed/notarized)
        id: macos_signed_build
        if: runner.os == 'macOS' && env.APPLE_CERTIFICATE != '' && env.APPLE_CERTIFICATE_PASSWORD != '' && env.APPLE_SIGNING_IDENTITY != ''
        continue-on-error: true
        working-directory: src-tauri
        run: cargo tauri build

      - name: Build app bundle (macOS unsigned fallback)
        if: runner.os == 'macOS' && (env.APPLE_CERTIFICATE == '' || env.APPLE_CERTIFICATE_PASSWORD == '' || env.APPLE_SIGNING_IDENTITY == '' || steps.macos_signed_build.outcome == 'failure')
        working-directory: src-tauri
        run: |
          if [ "${{ steps.macos_signed_build.outcome || '' }}" = "failure" ]; then
            echo "WARNING: macOS signed build failed. Falling back to unsigned build."
          else
            echo "WARNING: Missing macOS signing secrets (APPLE_CERTIFICATE/APPLE_CERTIFICATE_PASSWORD/APPLE_SIGNING_IDENTITY). Building unsigned artifact."
          fi
          unset APPLE_CERTIFICATE APPLE_CERTIFICATE_PASSWORD APPLE_SIGNING_IDENTITY APPLE_ID APPLE_PASSWORD APPLE_TEAM_ID
          cargo tauri build
          mkdir -p target/release/bundle/metadata
          cat > target/release/bundle/metadata/UNSIGNED-MACOS-BUILD.txt << 'EOF'
          This macOS artifact is unsigned and not notarized.
          Configure APPLE_CERTIFICATE/APPLE_SIGNING_IDENTITY/APPLE_ID/APPLE_PASSWORD/APPLE_TEAM_ID for signed releases.
          EOF

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: flamingo-${{ matrix.artifact_suffix }}
          path: |
            src-tauri/target/release/bundle/**/*.dmg
            src-tauri/target/release/bundle/**/*.msi
            src-tauri/target/release/bundle/**/*.exe
            src-tauri/target/release/bundle/**/*.AppImage
            src-tauri/target/release/bundle/**/*.deb
            src-tauri/target/release/bundle/**/*.rpm
            src-tauri/target/release/bundle/**/*.app.tar.gz
            src-tauri/target/release/bundle/metadata/*.txt
            browser-extension/dist/*.zip
          if-no-files-found: error

  release:
    if: startsWith(github.ref, 'refs/tags/v')
    needs: [ build ]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-assets
          merge-multiple: false

      - name: Verify release assets
        shell: bash
        run: |
          set -euo pipefail
          echo "Collected release assets:"
          find release-assets -type f -print
          count="$(find release-assets -type f | wc -l | tr -d ' ')"
          if [ "${count}" -eq 0 ]; then
            echo "No release assets found under release-assets/"
            exit 1
          fi
          echo "Asset file count: ${count}"

      - name: Normalize artifact names + checksums
        shell: bash
        run: |
          set -euo pipefail
          tag="${GITHUB_REF_NAME:-${GITHUB_REF##*/}}"
          mkdir -p release-assets-flat
          shopt -s globstar nullglob

          linux_count=0
          windows_count=0
          macos_arm64_count=0
          macos_x64_count=0

          for f in release-assets/**/*; do
            [ -f "$f" ] || continue
            bn="$(basename "$f")"
            platform="unknown"
            case "$f" in
              *flamingo-linux-x64/*) platform="linux-x64"; linux_count=$((linux_count + 1)) ;;
              *flamingo-windows-x64/*) platform="windows-x64"; windows_count=$((windows_count + 1)) ;;
              *flamingo-macos-arm64/*) platform="macos-arm64"; macos_arm64_count=$((macos_arm64_count + 1)) ;;
              *flamingo-macos-x64/*) platform="macos-x64"; macos_x64_count=$((macos_x64_count + 1)) ;;
            esac

            ext=""
            case "$bn" in
              flamingo-browser-extension-*.zip)
                cp "$f" "release-assets-flat/$bn"
                continue
                ;;
              *.AppImage) ext=".AppImage" ;;
              *.dmg) ext=".dmg" ;;
              *.msi) ext=".msi" ;;
              *.exe) ext=".exe" ;;
              *.deb) ext=".deb" ;;
              *.rpm) ext=".rpm" ;;
              *.app.tar.gz) ext=".app.tar.gz" ;;
              *.tar.gz) ext=".tar.gz" ;;
              *.zip) ext=".zip" ;;
              *) continue ;;
            esac

            out="Flamingo-Downloader-${tag}-${platform}${ext}"
            cp "$f" "release-assets-flat/$out"
          done

          if [ "$linux_count" -eq 0 ] || [ "$windows_count" -eq 0 ] || [ "$macos_arm64_count" -eq 0 ]; then
            echo "Expected artifacts missing: linux=$linux_count windows=$windows_count macos-arm64=$macos_arm64_count"
            exit 1
          fi

          if [ "$macos_x64_count" -eq 0 ]; then
            echo "NOTICE: no macos-x64 artifacts found (runner may be unavailable in this region/plan)"
          fi

          if ! find release-assets-flat -type f | grep -q .; then
            echo "No normalized release assets generated"
            exit 1
          fi

          (cd release-assets-flat && sha256sum * > SHA256SUMS.txt)
          echo "Normalized assets:"
          find release-assets-flat -type f -print

      - name: Generate release notes
        shell: bash
        run: |
          set -euo pipefail
          tag="${GITHUB_REF_NAME:-${GITHUB_REF##*/}}"

          git fetch --tags --force >/dev/null 2>&1 || true

          previous_tag="$(git tag --sort=-version:refname | grep -v "^${tag}$" | head -n 1 || true)"
          if [ -n "${previous_tag}" ]; then
            commit_range="${previous_tag}..${tag}"
          else
            commit_range="${tag}"
          fi

          commits="$(git log --no-merges --pretty='%s|%h' ${commit_range} | head -n 80 || true)"
          if [ -z "${commits}" ]; then
            commits="chore: maintenance updates|HEAD"
          fi

          features_tmp="$(mktemp)"
          fixes_tmp="$(mktemp)"
          ci_tmp="$(mktemp)"
          other_tmp="$(mktemp)"
          while IFS='|' read -r subject short_hash; do
            [ -n "${subject}" ] || continue
            line="- ${subject} (${short_hash})"
            lower_subject="$(echo "${subject}" | tr '[:upper:]' '[:lower:]')"
            if echo "${lower_subject}" | grep -Eq '^(feat)(\(.+\))?:'; then
              echo "${line}" >> "${features_tmp}"
            elif echo "${lower_subject}" | grep -Eq '^(fix|hotfix)(\(.+\))?:'; then
              echo "${line}" >> "${fixes_tmp}"
            elif echo "${lower_subject}" | grep -Eq '^(ci|build|chore\(ci\)|chore\(release\))(\(.+\))?:'; then
              echo "${line}" >> "${ci_tmp}"
            else
              echo "${line}" >> "${other_tmp}"
            fi
          done <<< "${commits}"

          cp .github/RELEASE_TEMPLATE.md release-notes.md
          sed -i "s/__VERSION__/${tag}/g" release-notes.md
          {
            echo ""
            echo "## What's New"
            if [ -s "${features_tmp}" ]; then
              echo "### Features"
              cat "${features_tmp}"
              echo ""
            fi
            if [ -s "${fixes_tmp}" ]; then
              echo "### Fixes"
              cat "${fixes_tmp}"
              echo ""
            fi
            if [ -s "${ci_tmp}" ]; then
              echo "### CI / Build"
              cat "${ci_tmp}"
              echo ""
            fi
            if [ -s "${other_tmp}" ]; then
              echo "### Other"
              cat "${other_tmp}"
              echo ""
            fi
            echo ""
            echo "## Artifacts"
            find release-assets-flat -maxdepth 1 -type f \
              | sed 's#^.*/##' \
              | sort \
              | sed 's/^/- /'
          } >> release-notes.md

      - name: Publish GitHub release
        uses: softprops/action-gh-release@v2
        with:
          files: release-assets-flat/**/*
          fail_on_unmatched_files: false
          overwrite_files: true
          body_path: release-notes.md
